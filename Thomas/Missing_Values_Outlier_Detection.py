# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.13.0
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# +
import pandas as pd
import numpy as np
import missingno as mso

from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
# -

df = pd.read_csv('D:/packt/Project/1019_Microsoft_Malware_Detection/Dataset/Malware_Classification.csv/Malware_Classification.csv')


# +
mask = df.isnull()
total = mask.sum()
percent = 100*(mask.mean())

missing_data = pd.concat([total, percent], axis = 1, join = 'outer', keys = ['count_missing','perc_missing'])
missing_data.sort_values(by='count_missing', inplace =True, ascending = False)
missing_data.head(3)
# -

# missing values just in 2 col, one is unnamed(most of them are missing, hence drop) and the other is MajorLinkerVersion (just one missing)

corr = df.corr()
corr[(corr.MajorLinkerVersion > 0.4) | (corr.MajorLinkerVersion < -0.4) ].MajorLinkerVersion

# model based imputation

# +
data_model_impute = df[["ImportsNbDLL","MajorLinkerVersion"]]
LinReg = LogisticRegression(multi_class = 'ovr')
test_model_impute = data_model_impute[data_model_impute.isnull().any(axis=1)]
train_model_impute = data_model_impute.dropna(axis = 0)

X_train, X_val, y_train, y_val = train_test_split(train_model_impute['ImportsNbDLL'],
                                                  train_model_impute['MajorLinkerVersion'],
                                                  test_size=0.33, random_state=42)

LinReg.fit(X_train.values.reshape(-1, 1), y_train)
y_val_hat = LinReg.predict(X_val.values.reshape(-1, 1))



imputation_value = LinReg.predict(test_model_impute['ImportsNbDLL'].values.reshape(-1, 1))[0]
print(f'the value to be impouted is {imputation_value}')

print(accuracy_score(y_val.values, y_val_hat))
# -

# class based imputation

# +
class_for_missing = df[df['MajorLinkerVersion'].isnull()]['legitimate'].values[0]
print(f' class of legitimay for missing value {class_for_missing}')

round(df.groupby('legitimate')['MajorLinkerVersion'].mean().to_dict()[class_for_missing])
# -







# !jupytext --to py Missing_Values_Outlier_Detection.ipynb


